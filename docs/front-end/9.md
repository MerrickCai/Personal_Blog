---
layout: docs
title: JS
description: JS
---

# JS

## 数据类型
- 原始类型(原始值, 传值) 
   - Undefined
   - Null(对空对象的引用)
   - Boolean
   - Number
   - String
   - Symbol(ES6)
- 引用类型(引用值, 传址) 
   - Object是一个基础类型，所有引用类型都从它继承了基本的行为
   - 函数也是一种引用类型，函数是Function类型的实例
   - 引用值（就是对象）是某个特定引用类型的实例，新的对象通过new操作符后跟一个构造函数（constructor）来创建
   - 基本引用类型 
      - Date(构造函数，实例化再使用)
         - getFullYear()  年份
         - getMonth()  0-11月
         - getDate()  日期
         - getDay()  星期：0-6（0是周日）
         - getHours() 0-23时
         - getMinutes() 0-59分钟
         - getSeconds()
         - getTime() 时间戳
         - Date.now()===+new Date()===new Date().valueOf()===Number(new Date()) 时间戳
      - RegExp
      - 原始值包装类型 
         - Boolean
         - Number
            - Number.isInteger()
            - toFixed()
            - Math.PI
            - Math.abs()
            - Math.random()     [0,1)
               - 生成[0,x)：Math.random()*x
               - 生成[x,y)：Math.random()*(y-x)+x
               - 生成[x,y]：Math.floor(Math.random()*(y-x+1))+x
            - Math.floor()
            - Math.ceil()
            - Math.round()
            - Math.max()
            - Math.min()
            - Math.pow()
            - Math.sqrt()
         - String
            - indexOf(), lastindexOf()
            - search()
            - includes()
            - startsWith()
            - endsWith()
            - charAt()等效str[index]
            - charCodeAt(index)
            - slice()
            - substring()
            - substr()
            - concat()
            - split()
            - replace()
            - String.fromCharCode([unicode])
            - repeat()
            - toLowerCase()
            - toUpperCase()
         - 每当原始值使用属性和方法时，后台会创建一个相应原始包装类型的对象
      - 单例内置对象 
         - 任何由ECMAScript实现提供，与宿主环境无关，并在ECMAScript程序开始执行就存在的对象，不需要显式地实例化内置对象
         - Global: 在全局作用域的变量和函数都会成为Global对象的属性，isNaN(), isFinite(), parseInt(), parseFloat(), encodeURI(), encodeURIComponent(), decodeURI(), decodeURIComponent()等都是Global对象的方法，undefined, NaN, Infinity, Object, Array, Function, Boolean, String, Number, Date等对象都是Global对象的属性（浏览器宿主环境下把window对象做为Global对象的代理）
         - Math: 属性和方法（上网查）：abs, sin, cos, tan等
   - 集合引用类型 
      - Object 
         - 显式地创建Object实例，一种是用new操作符和Object构造函数，另一种是使用对象字面量(属性名可以是字符串或数值)
         - 对象的属性是用点语法来存取的，或者用中括号(括号内要使用属性名的字符串形式)
         - 每个Object实例都有以下属性和方法 
            - constructor: 创建当前对象的函数
            - hasOwnProperty(propertyName[属性名: 字符串或Symbol]): 用于判断当前对象实例是否存在给定的属性
            - isPrototypeOf(object): 判断当前对象是否为另一个对象的原型
            - propertyIsEnumerable(propertyName[属性名: 字符串或Symbol]): 判断给定属性能否用for-in语句枚举
            - toLocaleString(): 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
            - toString(): 返回对象的字符串表示
            - valueOf(): 返回对象对应的字符串、数字、布尔值表示
      - Array(数组) 
         - 创建数组方式：Array构造函数, 或数组字面量
         - 属性和方法
            - Array.length
            - Array[i]
            - Array.sort(--)
            - Array.forEach(--，callback func)
            - Array.map(--,同上但返回数组)
            - Array.unshift(--)第一位添加元素
            - Array.push(--)最后一位添加元素
            - 创建多维数组
               - Array.from(--)
               - Array.fill(--)填充数组
               - Array.from(new Array(r), ()=>{new Array(c).fill(0)});
               - new Array(r).fill(0).map(()=>{new Array(c).fill(0)});
      - Map(ES6): 实现”键/值“式存储的新标准
      - Set(ES6): 集合类型

## 变量声明规范

- 尽量使用ES6新出的let和const声明变量而不是var 
   - let: 块作用域,且没有声明提升
   - const: 声明并赋值, 声明对象时，对象不可再赋值，但是可以修改对象的属性方法

## 执行上下文

- 每个上下文都有一个关联的变量对象
- 全局上下文就是最外层的上下文: 取决于SCMAScript的宿主环境，浏览器中全局上下文就是window对象，所有通过var定义的全局变量和函数都会成为window对象的属性和方法，使用let和const的顶级声明则不会定义在上下文中，在函数内未声明就初始化的变量会加到全局上下文
## 模板字面量定义字符串(ES6)

- 用法: `--${js表达式}--`
- 会保留内部的空格
## try catch语法糖
```javascript
try{

  //throw(error)
}catch(error){

}finally{

}
```
## 语句

- for-in语句 
   - 一种严格的迭代语句，用于枚举对象中的非符号键属性 
      - 用法：for(propertyname in expression){ statement }
- for-of语句 
   - 一种严格的迭代语句，用于遍历可迭代对象(数组等)的元素 
      - 用法：for(element of expression){ statement }
- with语句: 将代码的作用域设置为特定的对象 
   - 用法: with(expression){statement}

## BOM

- window对象(BOM的核心是, 表示浏览器的实例)：window对象在浏览器有双重身份，一个是ECMAScript中的Global对象，另一个是浏览器窗口的JavaScript接口 
   - window.devicePixelRatio: 物理像素与CSS像素的比值
   - window.innerWidth, window.innerHeight: 返回页面视口大小（不包括边框和工具栏）
   - window.outerWidth, window.outerHeight: 返回浏览器窗口大小
   - window.pageYoffset（scrollY）: 返回浏览器滚动距离
   - window.open(): 导航和打开新窗口
   - window.setTimeout(), window.setInterval(): 定时器
   - window.alert(), window.confirm(), window.prompt():系统对话框
- location对象（既是window的属性，也是document的属性）：保存了当前窗口中加载文档的信息，可修改浏览器地址
- navigator对象：浏览器自身的信息
- screen对象（少用）
- history对象（window的属性）：表示当前窗口首次使用以来用户的导航历史记录->历史状态管理（pjax，红宝书第380页） 
   - history.pushstate(): 代办

## DOM

- DOM1 
   - Node: 节点的属性和方法 
      - nodeType
      - nodeName, nodeValue
      - childNodes(类数组), parentNode, firstChild, lastChild, previousSibling, nextSibling
      - appendChild(): 在childNodes列表末尾添加节点, insertBefore(), replaceChild(), removeChild()
      - cloneNode()
      - normalize()
   - document(是window对象的属性) 
      - document.doctype 返回 `<!DOCTYPE html>`
      - document.documentElement就是html元素
      - document.body就是body元素
      - document.title, document.URL, document.domain, document.referrer
      - document.getElementById(), document.getElementsByTagName(), getElementsByName(): 过时
      - document.anchors: 包含文档中所有带name属性的a元素, document.links: 包含文档中所有带href属性的a元素
      - document.write()
   - 通过document.getElementById()等方法获得的html元素有属性和方法->读取+修改属性 
      - id, title, lang, dir, className
      - getAttribute(), setAttribute(要设置的属性名, 属性的值), removeAttribute()
   - 创建元素：document.createElement("标签名")
- DOM 扩展 
   - document.querySelector(), document.querySelectorAll()->返回静态list
   - document.getElementsByClassName()->返回动态list
   - element.classList 是某元素的class属性 
      - element.classList.add(""): 向类名列表中添加指定的字符串，若存在则什么的不做
      - element.classList.remove(""): 从类名列表中删除指定字符串
      - element.classList.toggle(""): 如果类名列表中存在指定字符串，则删除；不存在则添加
   - element.focus()：焦点, element.hasFocus():判断焦点是否在元素上, 返回布尔值
   - document.head就是head元素
   - element.innerHTML：内容操作,可改元素内的元素及内容
- DOM2/3 
   - element.style.(color/display等)：改元素的内联样式，style为元素的style对象
   - element.style.setProperty(propertyName,value,priority["important"/""(空字符串)])，element.style.removeProperty(propertyName)
   - element.style.cssText（可修改）
   - document.defaultView.getComputedStyle(element, null): 获取元素的css计算样式(只读)
   - document.styleSheets返回样式表节点数组，document.styleSheets.length表示数量 
      - document.styleSheets[i].cssRules: 当前样式表包含的样式规则的集合 
         - document.styleSheets[i].cssRules[i].cssText: 返回整条规则的文本
         - document.styleSheets[i].cssRules[i].selectorText: 返回这条规则的选择器
   - element.offsetLeft和element.offsetTop: 返回元素对应边框相对包含元素边框的距离（像素）
   - element.offsetHeight和element.offsetWidth：返回对应长度（包括滚动条、边框，内边距，内容）
   - element.clientHeight和element.clientWidth：返回对应长度（包括内边距，内容）
   - element.scrollHeight和element.scrollWidth: 返回没有滚动条时元素内容总长度(包括内边距，内容)
   - element.scrollLeft和element.scrollTop（可设置）：返回内容区左侧相对于可见区域的长度，往右滚动有端位移
   - element.getBoundingClientRect():返回一个对象,属性：left, top, right, bottom, height, width(相对视口的位置)

## 事件处理程序（监听器）

- HTML：行内声明（`onclick='func(event)'`）->过时 
   - 会有一个局部变量event对象
   - 而且能扩展作用域，在函数中document对象和元素自身的成员都当局部变量访问(with实现)
```
function(){
    with(document){
        with(this){
            statement;
        }
    }
}
```
 

- DOM0级 
   - 用法：element.onclick(或别的事件属性)=function(){};其中this为此元素
   - 移除：element.onclick=null;
- DOM2级 
   - element.addEventListener("[event]",[func],[false(默认，冒泡)])
   - element.removeEventListener(参数): 参数与addEventListener一样时才能remove那个添加的监听->若监听事件处理函数是匿名函数则不能remove
- 事件对象event 
   - event.currentTarget(即this): 事件处理函数所在的元素
   - event.target: 触发事件的目标(因为是冒泡，有时候点击的元素并没有事件监听，但冒泡过程中有元素有监听器，这样子的话，target就是触发事件的元素，currentTarget就是绑定了点击事件的元素)
event.type: 返回事件的类型, 若同一个元素有多个事件处理，就有用
event.preventDefault()，用于把某事件的默认行为取消，比如a标签的点击跳转
event.stopPropagation(): 取消后续事件的冒泡
-用户界面事件
   - load`window.addeventlistener("load",func)` (本应该由document触发，考虑兼容性window也行)
   - resize(window触发)
   - scroll(window触发)
- 焦点事件 
   - blur, focusout
   - focus, focusin
- 鼠标和滚轮事件 
   - click
   - mouseover
   - mouseout
   - mousemove
   - mouseenter: 在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发
   - mouseleave: 在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。
   - 客户端坐标 
      - event对象的clientX和clientY属性（事件触发时鼠标相对视口的坐标）
      - event对象的pageX和pageY属性（事件触发时鼠标相对页面的坐标）
      - event对象的screenX和screenY属性（事件触发时鼠标相对电脑屏幕窗口的坐标）
- 其他事件 
   - window 的 load 事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而 document的DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS 文件或其他资源加载完成
   - window的hashchange事件 ：用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者。这是因为开发者经常在 Ajax 应用程序中使用 URL 散列值存储状态信息或路由导航信息
- 触摸事件：代办（红宝书p531）
- 模拟事件：代办（红宝书p543）

## js对象

是一组属性的无序集合，内容是键值对

### 属性的类型：用内部特性来描述属性的特征

- 数据属性（常规的属性），以下是内部特性 
   - [[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true
   - [[Enumerable]]: 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true
   - [[Writable]]: 表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true
   - [[Value]]: 包含属性实际的值
   - 修改属性的数据特征用Object.defineProperty(object,property,描述符对象)：描述符对象比如 {writable: false,value: "Nicholas"}，注意：把configurable设置成false之后就不能再用defineProperty()方法处理同一个属性，而且调用defineProperty()，如果没声明的数据特征会自动为false
- 访问器属性：是一种特别的属性，没有值，包含一个获取（getter）函数和一个设置（setter）函数，。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改 
   -  访问器属性有四个特性 
      - [[Configurable]]
      - [[Enumerable]]
      - [[Get]]
      - [[Set]]

```js
// 定义一个对象，包含伪私有成员 year_和公共成员 edition
let book = {
   year_: 2017,
   edition: 1
};
Object.defineProperty(book, "year", {
   get() {
      return this.year_;
   },
   set(newValue) {
      if (newValue > 2017) {
         this.year_ = newValue;
         this.edition += newValue - 2017;
      }
   }
});
book.year = 2018;
console.log(book.edition); // 2 相当于这个属性的设置可以更新对象中别的属性
```

#### 对象操作

- 删除对象属性 delete obj.pro
- 定义多个属性Object.defineProperties(obj,{描述符对象})  
   比如`{pro1:{描述符对象},pro2:{描述符对象}}`
- Object.getOwnPropertyDescriptor(obj,proName): 读取对象属性的特性，返回一个对象
- Object.getOwnPropertyDescriptors(obj): 返回该对象每个自有属性的特性的对象集合
- 合并对象-> Object.assign(目标对象，一个或多个源对象)，是一种浅复制：然后将每个源对象中可枚举（obj.propertyIsEnumerable()返回 true）和自有（obj.hasOwnProperty()返回 true）属性复制到目标对象 
   - 以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值
- 对象标识及相等判定：Object.is(a,b)

### 增强的对象语法

ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性，这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度

- 属性值简写：如果属性名和变量名一样，可简写
- 可计算属性：[]中括号包围起来的js表达式做对象字面量的属性 
   - ES5中只能添加属性
      ```js
      const nameKey = 'name';
      const ageKey = 'age'; 
      const jobKey = 'job';
      let person = {};
      person[nameKey] = 'Matt';
      person[ageKey] = 27;
      person[jobKey] = 'Software engineer';
      ```
   - 可计算属性与属性值简写不兼容
- 简写方法名 
   - 新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名
   - 简写方法名对获取函数和设置函数也是适用的（新的语法糖：get set可以在对象字面量中直接定义比如`let ob={a:5,get name(){},set name(){}};`中定义了name属性（访问器属性）的get和set函数）
   - 简写方法名与可计算属性键相互兼容

#### 对象解构

就是使用与对象匹配的结构来实现对象属性赋值, 一种新的赋值方式

```js
// 使用对象解构
let person = {
name: 'Matt',
age: 27
};
let { name: personName, age: personAge } = person;
console.log(personName); // Matt
console.log(personAge); // 27 

let person = {//变量名跟属性名一样可进一步简写
name: 'Matt',
age: 27
};
let { name, age } = person;
console.log(name); // Matt
console.log(age); // 27 

let { name, job='Software engineer' } = person;//可设置默认值
```

- 解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中
   ```js
   let personName, personAge;
   let person = {
   name: 'Matt',
   age: 27
   };
   ({name: personName, age: personAge} = person);
   ```

- 嵌套解构：原理很简单
- 部分解构:发生错误不回滚
- 参数上下文匹配：在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明在函数体内使用局部变量
   ```js
   let person = {
   name: 'Matt',
   age: 27
   };
   function printPerson(foo, {name, age}, bar) {
   console.log(arguments);
   console.log(name, age);
   }
   function printPerson2(foo, {name: personName, age: personAge}, bar) {
   console.log(arguments);
   console.log(personName, personAge);
   }
   printPerson('1st', person, '2nd');
   // ['1st', { name: 'Matt', age: 27 }, '2nd']
   // 'Matt', 27
   printPerson2('1st', person, '2nd');
   // ['1st', { name: 'Matt', age: 27 }, '2nd']
   // 'Matt', 27
   ```

#### 创建对象

- ECMAScript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，ES6 的类都仅仅是封装了 ES5构造函数加原型继承的语法糖而已
- 工厂模式：简单粗暴用new Object()创建空对象并手动赋值
- 构造函数(构造函数名最好大写),定义后用new关键字
   ```js
   function Person(name, age, job){
   this.name = name;
   this.age = age;
   this.job = job;
   this.sayName = function() {
   console.log(this.name);
   };
   }
   let person1 = new Person("Nicholas", 29, "Software Engineer");
   let person2 = new Person("Greg", 27, "Doctor");
   ```
   - 新创建的对象的constructor属性指向构造函数，而且也是构造函数的实例，instanceof返回true
   - 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性
   - 构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数
   - 构造函数也是函数
   - 构造函数的问题构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍: 要解决这个问题，可以把函数定义转移到构造函数外部
- 原型模式 
   - 每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法（实际上，这个对象就是通过调用构造函数创建的实例对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型）
   - 代办（红宝书p224）

## 动画

- window.requestAnimationFrame()方法，参数为一个回调函数，回调函数内可重复使用window.requestAnimationFrame()，可绘制连续动画
- window.cancelAnimationFrame()，接受一个参数（为window.requestAnimationFrame()的返回值）,可取消动画
- window.requestAnimationFrame()节流
   ```js
   let enqueued = false
   function expensiveOperation() {
   console.log('Invoked at', Date.now())
   enqueued = false
   }
   window.addEventListener('scroll', () => {
   if (!enqueued) {
   enqueued = true
   window.requestAnimationFrame(expensiveOperation)
   }
   })
   ```

## 画布 Canvas

### 基础

- 创建canvas元素要设置width和height属性
- 用js创建指定canvas元素的上下文对象

const canvas=document.querySelector("");
const context=canvas.getContext("2d");
### 2D绘图上下文的方法和属性

- 2d绘图上下文提供了绘制2d图形的方法，包括矩形、弧形、路径，2d上下文的坐标原点（0，0）在canvas元素的左上角，所有坐标值都相对该点计算
- 两个基本操作：填充和描边，对应两个属性：fillStyle和strokeStyle，可设置颜色
- 绘制矩形 
   - fillRect(x,y,width,height): 指定颜色在画布绘制并填充矩形, 颜色用fillStyle指定
   - strokeRect(x,y,width,height): 通过 strokeStyle 属性指定的颜色绘制矩形轮廓
   - clearRect(x,y,width,height): 可以擦除画布中某个区域, 该方法用于把绘图上下文中的某个区域变透明，通过先绘制形状再擦除指定区域
- 绘制路径 
   - 首先调用beginPath()方法开始绘制新路径
   - arc(x,y,radius,startAngle,endAngle,counterclockwise):，(x,y)为圆心以x轴正方向为初始角度,-pi/2就是y轴（和数学三角函数相反）
   - arcTo(x1,y1,x2,y2,radius):画弧线
   - lineTo(x,y): 绘制直线
   - moveTo(x,y)：不绘制线条，只把绘制光标移动到(x, y)
   - rect(x, y, width, height)：它创建的是一条路径，而不是独立的图形(使用时自动moveTo(0,0))
   - 创建路径之后，可以使用 closePath()方法绘制一条返回起点的线。
   - 如果路径已经完成 
      - 则既可以指定 fillStyle 属性并调用 fill()方法来填充路径
      - 也可以指定 strokeStyle 属性并调用stroke()方法来描画路径
- 绘制文本 
   - 两个方法都接受四个参数：要绘制的字符串、x 坐标、y 坐标和最大像素宽度(可选)
   - fillText()：使用fillStyle 属性绘制文本
   - strokeText()：使用strokeStyle属性
   - font属性：以CSS语法指定的字体样式、大小、字体族等，比如"bold 16px Arial"
   - textAlign属性：指定文本的对齐方式（"center"、"start"和"end"）
   - textBaseLine属性：指定文本的基线（"middle"）
- save()和restore()保存和恢复画布状态，不是绘图！！
- 变换等（红宝书p560）
